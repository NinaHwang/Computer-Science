# 3. Relational Design Theory

Created: August 5, 2021 4:09 PM<br>
Lecture: Databases: Modeling and Theory<br>
Materials: https://learning.edx.org/course/course-v1:StanfordOnline+SOE.YDB-MDL_THEORY0001+2T2020/home#block-v1:StanfordOnline+SOE.YDB-MDL_THEORY0001+2T2020+type@chapter+block@ch-relational_design_theory<br>
Type: Lecture

# Relational Design Overview

## Designing a Database [Schema](https://terms.naver.com/entry.naver?docId=836327&cid=42344&categoryId=42344)

- Usually many designs possible
- Some are (much) better than others! → how do we choose?

Often use higher-level design tools, but..

- Some designers go straight to relations
- Useful to understand why tools produce certain schemas

### Example 1

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_16.16.30.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_16.16.30.png)

⇒ Not a good design(design anomalies)

**Design "anomalies"**

- Redundancy → capture info multiple times
- Update anomaly → you can update facts in some places but not all or differently in different places
- Deletion anomaly

### Example 2

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_16.21.50.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_16.21.50.png)

⇒ No anomalies, reconstruct original data

## Design by Decomposition

- Start with "mega" relations containing everything
- Decompose into smaller, better relations with same info.
- Can do decomposition automatically

Automatic decomposition

- "Mega" relations *+ properties of the data*
- System decomposes based on properties
- Final set of relations satisfies *normal form*
    - No anomalies, no lost information

### **Properties and Normal Forms**

- **Functional dependencies**
    - Boyce-Codd Normal Form: two early pioneers in relational databases in general

    [Functional dependency - Wikipedia](https://en.wikipedia.org/wiki/Functional_dependency)

    [Boyce-Codd normal form - Wikipedia](https://en.wikipedia.org/wiki/Boyce%E2%80%93Codd_normal_form)

- **Multivalued dependencies** (add to functional dependencies)
    - Fourth Normal Form: relations that are generated by the system that satisfy the normal form → stricter than Boyce-Codd Normal Form

    [Multivalued dependency - Wikipedia](https://en.wikipedia.org/wiki/Multivalued_dependency)

    [Fourth normal form - Wikipedia](https://en.wikipedia.org/wiki/Fourth_normal_form)

**Functional Dependencies and BCNF**

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_16.44.42.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_16.44.42.png)

**Multivalued Dependencies and 4NF**

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_16.38.16.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_16.38.16.png)

# Functional Dependencies

Functional dependencies are generally useful concepts ⇒ generalization of the notion of keys

- Data storage - compression
- Reasoning about queries - optimization

## A Few Definitions Related to Functional Dependencies

- Trivial Functional Dependency
    - A functional dependency is trivial A to B if B is a subset of A
- Nontrivial FD
    - A functional dependency that's not a trivial one
    - there are some attributes in B that are not part of A
- Completely nontrivial FD
    - A determines B where A and B have no intersection at all

## Rules for Functional Dependencies

### Splitting Rule

We can split the right side of the functional dependency(NOT the left side)

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_17.39.34.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_17.39.34.png)

### Combining Rule

Combining rule is the inverse of the splitting rule

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_17.41.58.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_17.41.58.png)

### Trivial-dependency Rules

A determines B where B is a subset of A

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_17.42.24.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_17.42.24.png)

### Transitive Rule

If A determines B and B determines C, A determines C

## Closure of Attributes

- Given relation, FDs, set of attributes $\bar{A}$
- Find all B such that $\bar{A} → B$

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_17.50.35.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_17.50.35.png)

### Closure and Keys

Is $\bar{A}$  a key for R?

- Compute the closure of A and if that equals all attributes, then A is the key.

How can we find all keys given a set of FDs?

- Consider every subset of attrs

# Boyce-Codd Normal Form

Relation R with FDs is in BCNF if..

⇒ For each $\bar{A} → B, \bar{A}$  is a key

## Decomposition of a Relational Schema

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_18.12.37.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_18.12.37.png)

## BCNF Decomposition Algorithm

**Input**: relation R + FDs for R

**Output**: decomposition of R into BCNF relations w/ "lossless join"

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_18.25.29.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_18.25.29.png)

### BCNF Decomposition Example

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_20.18.55.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_20.18.55.png)

# Multivalued Dependencies and 4th Normal Form

## Multivalued Dependency

Based on knowledge of real world

All instances of relations must adhere

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_23.04.54.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_23.04.54.png)

## Trivial Multivalued Dependency & Nontrivial MVD

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_23.15.52.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_23.15.52.png)

## Rules for Multivalued Dependencies

**FD-is-an-MVD rule**

- $\bar{A}→\bar{B}$ then $\bar{A} \twoheadrightarrow \bar{B}$

**Intersection rule**

- $\bar{A}\twoheadrightarrow\bar{B}$ and $\bar{A} \twoheadrightarrow \bar{C}$ then  $\bar{A}\twoheadrightarrow\bar{B} \cap \bar{C}$

**Transitive rule**

- $\bar{A}\twoheadrightarrow\bar{B}$ and $\bar{B} \twoheadrightarrow \bar{C}$ then $\bar{A}\twoheadrightarrow\bar{C} - \bar{B}$

## Fourth Normal Form

Relation R with MVDs is in 4NF if..

⇒ For each nontrivial A ↠ B, A is a key

## 4NF Decomposition Algorithm

**Input**: relation R + FDs for R + MVDs for R

**Output**: decomposition of R into 4NF relations with "lossless join"

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_23.27.21.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_23.27.21.png)

### 4NF Decomposition Example

![3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_23.33.33.png](3%20Relational%20Design%20Theory%20d331f7471fb34ce2899368694f8b6fab/Screen_Shot_2021-08-05_at_23.33.33.png)

# Shortcomings of BCNF/4NF

**Dependency enforcement**

After decomposition, no guarantee dependencies can be checked on decomposed relations

⇒ they may require joins of those relations in oder to check them

**Query workload**

When queries tend to access all attributes, when every query would be reassembling the normalized relations, it actually might be preferable to use one that is "Denormalized"

**Over-decomposition**

"Too decomposed"
